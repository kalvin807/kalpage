---
export const prerender = false;

import sharp from 'sharp';

const MAX_COLS = 28;
const MAX_RETRIES = 3;
const CACHE_TTL_SECONDS = 60 * 60 * 6;
const CACHE_TTL_MS = CACHE_TTL_SECONDS * 1000;
const SEARCH_URL =
  'https://collectionapi.metmuseum.org/public/collection/v1/search?departmentId=11&hasImages=true&q=painting';
const OBJECT_URL =
  'https://collectionapi.metmuseum.org/public/collection/v1/objects/';

interface PixelData {
  r: number;
  g: number;
  b: number;
}

interface PaintingInfo {
  title: string;
  artist: string;
  date: string;
  url: string;
}

interface PaintingPayload {
  pixels: PixelData[];
  cols: number;
  info: PaintingInfo;
}

type PaintingCache = {
  expiresAt: number;
  payload: PaintingPayload;
};

const globalCache = globalThis as typeof globalThis & {
  __paintingPixelsCache?: PaintingCache;
};

Astro.response.headers.set(
  'Cache-Control',
  `public, max-age=0, s-maxage=${CACHE_TTL_SECONDS}, stale-while-revalidate=86400`,
);
Astro.response.headers.set(
  'CDN-Cache-Control',
  `public, s-maxage=${CACHE_TTL_SECONDS}, stale-while-revalidate=86400`,
);
Astro.response.headers.set(
  'Vercel-CDN-Cache-Control',
  `public, s-maxage=${CACHE_TTL_SECONDS}, stale-while-revalidate=86400`,
);

let error = false;
let pixels: PixelData[] = [];
let cols = 0;
let info: PaintingInfo = { title: '', artist: '', date: '', url: '' };
const now = Date.now();
const cached = globalCache.__paintingPixelsCache;

try {
  if (cached && cached.expiresAt > now) {
    ({ pixels, cols, info } = cached.payload);
  } else {
    const searchRes = await fetch(SEARCH_URL);
    if (!searchRes.ok) throw new Error('Search API failed');
    const searchData = await searchRes.json();
    const objectIDs: number[] = searchData.objectIDs ?? [];
    if (objectIDs.length === 0) throw new Error('No paintings found');

    let imageUrl: string | null = null;

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      const id = objectIDs[Math.floor(Math.random() * objectIDs.length)];
      const objRes = await fetch(OBJECT_URL + id);
      if (!objRes.ok) continue;
      const obj = await objRes.json();
      if (!obj.isPublicDomain || !obj.primaryImageSmall) continue;

      imageUrl = obj.primaryImageSmall;
      info = {
        title: obj.title ?? 'Untitled',
        artist: obj.artistDisplayName ?? 'Unknown',
        date: obj.objectDate ?? '',
        url: obj.objectURL ?? '',
      };
      break;
    }

    if (!imageUrl) throw new Error('All retries exhausted');

    const imageRes = await fetch(imageUrl);
    if (!imageRes.ok) throw new Error('Image fetch failed');
    const imageBuffer = Buffer.from(await imageRes.arrayBuffer());

    const metadata = await sharp(imageBuffer).metadata();
    const origW = metadata.width!;
    const origH = metadata.height!;

    cols = MAX_COLS;
    const rows = Math.round((origH / origW) * cols);

    const rgbBuffer = await sharp(imageBuffer)
      .resize(cols, rows)
      .removeAlpha()
      .raw()
      .toBuffer();

    for (let i = 0; i < rgbBuffer.length; i += 3) {
      pixels.push({ r: rgbBuffer[i], g: rgbBuffer[i + 1], b: rgbBuffer[i + 2] });
    }

    globalCache.__paintingPixelsCache = {
      expiresAt: now + CACHE_TTL_MS,
      payload: { pixels, cols, info },
    };
  }
} catch {
  if (cached) {
    ({ pixels, cols, info } = cached.payload);
  } else {
    error = true;
  }
}
---

{error ? (
  <p class="painting-error">Could not load a painting this time.</p>
) : (
  <Fragment>
    <div class="painting-grid" style={`grid-template-columns:repeat(${cols},1fr)`}>
      {pixels.map(px => <div class="painting-pixel" style={`background:rgb(${px.r},${px.g},${px.b})`} />)}
    </div>
    <div class="painting-info">
      <a href={info.url} target="_blank" rel="noopener noreferrer" class="painting-link">
        <div class="painting-title">{info.title}</div>
        <div class="painting-artist">{[info.artist, info.date].filter(Boolean).join(' \u00b7 ')}</div>
      </a>
    </div>
  </Fragment>
)}
