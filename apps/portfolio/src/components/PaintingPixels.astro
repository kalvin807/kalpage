---
export const prerender = false;

import sharp from 'sharp';

const MAX_COLS = 28;
const MAX_RETRIES = 3;
const CACHE_TTL_SECONDS = 60 * 60 * 6;
const CACHE_TTL_MS = CACHE_TTL_SECONDS * 1000;
const SEARCH_URL = 'https://collectionapi.metmuseum.org/public/collection/v1/search?departmentId=11&hasImages=true&q=painting';
const OBJECT_URL = 'https://collectionapi.metmuseum.org/public/collection/v1/objects/';

interface PixelData {
  readonly r: number;
  readonly g: number;
  readonly b: number;
}

interface PaintingInfo {
  readonly title: string;
  readonly artist: string;
  readonly date: string;
  readonly url: string;
}

interface PaintingPayload {
  readonly pixels: PixelData[];
  readonly cols: number;
  readonly info: PaintingInfo;
}

interface PaintingCache {
  readonly expiresAt: number;
  readonly payload: PaintingPayload;
}

const globalCache = globalThis as typeof globalThis & {
  paintingPixelsCache?: PaintingCache;
};

async function fetchPaintingPixels(): Promise<PaintingPayload> {
  const now = Date.now();
  const cached = globalCache.paintingPixelsCache;

  try {
    if (cached && cached.expiresAt > now) {
      return cached.payload;
    }

    const searchRes = await fetch(SEARCH_URL);
    if (!searchRes.ok) throw new Error('Search API failed');
    const searchData = (await searchRes.json()) as unknown as { objectIDs?: number[] };
    const objectIDs = searchData.objectIDs ?? [];
    if (objectIDs.length === 0) throw new Error('No paintings found');

    let imageUrl: string | null = null;
    let info: PaintingInfo = { title: '', artist: '', date: '', url: '' };

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      const id = objectIDs[Math.floor(Math.random() * objectIDs.length)];
      const objRes = await fetch(OBJECT_URL + id);
      if (!objRes.ok) continue;
      const obj = (await objRes.json()) as unknown as Record<string, unknown>;
      if (!obj.isPublicDomain || !obj.primaryImageSmall) continue;

      imageUrl = obj.primaryImageSmall as string;
      info = {
        title: (obj.title as string) ?? 'Untitled',
        artist: (obj.artistDisplayName as string) ?? 'Unknown',
        date: (obj.objectDate as string) ?? '',
        url: (obj.objectURL as string) ?? '',
      };
      break;
    }

    if (!imageUrl) throw new Error('All retries exhausted');

    const imageRes = await fetch(imageUrl);
    if (!imageRes.ok) throw new Error('Image fetch failed');
    const imageBuffer = Buffer.from(await imageRes.arrayBuffer());

    const metadata = await sharp(imageBuffer).metadata();
    if (!metadata.width || !metadata.height) throw new Error('Missing image dimensions');

    const cols = MAX_COLS;
    const rows = Math.round((metadata.height / metadata.width) * cols);

    const rgbBuffer = await sharp(imageBuffer).resize(cols, rows).removeAlpha().raw().toBuffer();

    const pixels: PixelData[] = [];
    for (let i = 0; i < rgbBuffer.length; i += 3) {
      const r = rgbBuffer[i];
      const g = rgbBuffer[i + 1];
      const b = rgbBuffer[i + 2];
      if (r === undefined || g === undefined || b === undefined) {
        throw new Error('unreachable: rgbBuffer length not divisible by 3');
      }
      pixels.push({ r, g, b });
    }

    const payload: PaintingPayload = { pixels, cols, info };
    globalCache.paintingPixelsCache = { expiresAt: now + CACHE_TTL_MS, payload };
    return payload;
  } catch (e) {
    console.error('[PaintingPixels] Failed to fetch painting:', e);
    if (cached) {
      return cached.payload;
    }
    throw e;
  }
}

Astro.response.headers.set(
  'Cache-Control',
  `public, max-age=0, s-maxage=${CACHE_TTL_SECONDS}, stale-while-revalidate=86400`,
);

let error = false;
let result: PaintingPayload = { pixels: [], cols: 0, info: { title: '', artist: '', date: '', url: '' } };

try {
  result = await fetchPaintingPixels();
} catch {
  error = true;
}

const { pixels, cols, info } = result;
---

{error ? (
  <p class="painting-error">Could not load a painting this time.</p>
) : (
  <Fragment>
    <div class="painting-grid" style={`grid-template-columns:repeat(${cols},1fr)`}>
      {pixels.map(px => <div class="painting-pixel" style={`background:rgb(${px.r},${px.g},${px.b})`} />)}
    </div>
    <div class="painting-info">
      <a href={info.url} target="_blank" rel="noopener noreferrer" class="painting-link">
        <div class="painting-title">{info.title}</div>
        <div class="painting-artist">{[info.artist, info.date].filter(Boolean).join(' \u00b7 ')}</div>
      </a>
    </div>
  </Fragment>
)}
